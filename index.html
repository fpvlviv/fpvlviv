<html>

<head>
	<script>		
	    const htmlEscapes = {
	        '&': '&amp;',
	        '<': '&lt;',
	        '>': '&gt;',
	        '"': '&quot;',
	        "'": '&#39;'
	    };
		function escapeHtml(str) {
		    return str.replace(/[&<>"']/g, match => htmlEscapes[match]);
		}
		
		function getSelectorSelection(selectorId) {
			const selector = document.getElementById(selectorId);
			return { key:selector.value, value:selector.options[selector.selectedIndex].text };
		}

		async function runGenProfile() {
			const titles = [];
			const urls = [];
			
			dataFolders.forEach(dataFolder => {
				const selection = getSelectorSelection(dataFolder);
				titles.push(selection.value);
				urls.push('./data/' + dataFolder + '/' + selection.key + '.txt');
			});
			const values = await getMultipleContents(urls);
			
			const templateParams = {};
			dataFolders.forEach((dataFolder, index) => {
				templateParams[dataFolder] = values[index];
			});
			
			const profileContents = genProfile(templateParams);

			var a = document.createElement('a');
			a.href = URL.createObjectURL(new Blob([profileContents], { type: 'text/plain' }));
			
			a.download = titles.join('_').replaceAll(',', '').replaceAll(/[ ]+/g, '_') + '.txt';

			// Append the anchor to the body (required for Firefox)
			document.body.appendChild(a);
			// Programmatically click the anchor to trigger the download
			a.click();
			// Remove the anchor from the body
			document.body.removeChild(a);
			URL.revokeObjectURL(a.href);
		}

		function genProfile(params) {
			return evaluateTemplate(profileTemplate, params);
		}

		function evaluateTemplate(template, data) {
			for (const [key, value] of Object.entries(data)) {
				this[key] = value;
			}
			return new Function("return `" + template + "`;").call();
		}

		async function getContent(url) {
			const response = await fetch(url);
			if (!response.ok) {
				throw new Error(`Error: ${response.status}`);
			}
			const x = await response.text();
			return x;
		}
		
		async function getMultipleContents(urls) {
		    try {
		        const contentPromises = urls.map(url => getContent(url + "?nocache="+new Date().getTime()));
		        const contents = await Promise.all(contentPromises);
		        return contents;
		    } catch (error) {
		        console.error(error);
		    }
		}
		
		const selectTemplate = '<div><h4>${escapeHtml(title)}</h4><select id="${selectorId}">${options}</select></div>';
		const optionTemplate = '<option value="${escapeHtml(optValue)}">${escapeHtml(optName)}</option>';
		
		function createSelector(id, title, opts) {
			const optsHtml = Object.keys(opts).map(key => {
				const value = opts[key];
				return evaluateTemplate(optionTemplate, {optValue: key, optName: value});
			}).join('\n');
			return evaluateTemplate(selectTemplate, {selectorId: id, title, options: optsHtml});
		}
		
		function strToList(str) {
			return str.trim().split('\n');
		}

		function strToMap(str) {
			const result = {};
			const lines = strToList(str);
			lines.forEach(line => {
				const [key, ...valueParts] = line.split('=');
				const value = valueParts.length > 0 ? valueParts.join('=') : key;
		        result[key] = value;
			});
			return result;
		}

		getMultipleContents(["./data/template.txt", "./data/_index.txt"]).then(result => {
			window.profileTemplate = result[0];
			window.dataFoldersMap = strToMap(result[1]);
			window.dataFolders = Object.keys(dataFoldersMap);
			getMultipleContents(dataFolders.map(folderName => "./data/" + folderName + "/_index.txt")).then(indexesResult => {
				var html = '';
				for(var i = 0; i < dataFolders.length; i++) {
					html += createSelector(dataFolders[i], dataFoldersMap[dataFolders[i]], strToMap(indexesResult[i]));
				}
				document.body.insertAdjacentHTML('beforeend', html);
			});
		});
	</script>
</head>

<body>
	<div><button onclick="runGenProfile()">Скачати профіль</button></div>
</body>

</html>